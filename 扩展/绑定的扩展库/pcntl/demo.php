<?php

// 以下是pcntl扩展的一个Demo代码，用于演示如何在父进程中创建多个子进程并对其进行操作。
// 这个Demo中，我们将循环创建10个子进程，每个子进程会睡眠5秒，然后结束。
// 父进程会等待所有子进程结束后才退出。

$childProcesses = array();  // 子进程 ID 的数组

for ($i = 0; $i < 10; $i++) {
    $pid = pcntl_fork();  // 创建子进程

    if ($pid == -1) {
        // 创建子进程失败
        die('无法创建子进程');
    } elseif ($pid == 0) {
        // code logic // 在子进程中执行的代码
        sleep(5);  // 子进程睡眠 5 秒钟
        exit(0);  // 子进程直接退出
    } else {
        // code logic // 在父进程中执行的代码
        $childProcesses[] = $pid;  // 记录子进程 ID
    }
}

// 等待所有子进程结束后才退出
foreach ($childProcesses as $pid) {
    pcntl_waitpid($pid, $status);
}

// 这个Demo代码中使用了pcntl_fork函数创建子进程，并使用pcntl_waitpid函数等待子进程结束。
// pcntl_fork函数会返回两次，一次在父进程中返回子进程的ID号，另一次在子进程中返回0。如果创建子进程失败，则返回-1。

// 使用pcntl_waitpid函数可以等待指定的子进程结束，函数的第一个参数是要等待的子进程的ID号，第二个参数用于存储子进程的退出状态。
// 在这个Demo中，我们先将所有子进程的ID号存储在一个数组中，并在循环中调用pcntl_waitpid函数等待所有子进程结束。

// 注意
// 在上面的 Demo 代码中，子进程会休眠5秒钟，但这并不会导致脚本停止执行。
// 在子进程中，调用exit()函数或者让子进程自然结束时，子进程会自动退出；
// 父进程则会继续执行代码。

// 上面的脚本中，在某一时刻最多存在多少个 PHP 进程？
// 在这个脚本中，最多存在11个PHP进程，其中10个是子进程，1个是父进程。
// 在循环中，fork是在父进程中执行的，因此，每次循环都只会生成一个子进程。
// 所以在fork的时候，进程总数会增加一个，最多达到11个。但父进程在等待子进程退出后才会结束，所以子进程不会同时执行，每次只会有一个子进程在执行，即使是连续的fork，也只有同时存在一个子进程。
// 证明[查看PHP进程数------ 确实11个]
// ➜  php top -l 0 -s 2 -stats pid,ppid,cpu,mem,command,state | grep php
// 76423  1     0.0  3238M phpstorm         sleeping
// 66232  10116 0.0  9192K php              sleeping
// 66228  86718 0.0  9532K php              sleeping
// 66196  18300 0.0  9616K php              sleeping
// 66168  902   0.0  18M   php              sleeping
// 76423  1     5.4  3238M  phpstorm         sleeping
// 66168  902   0.0  18M    php              sleeping
// 66228  86718 0.0  9532K  php              sleeping
// 66196  18300 0.0  9616K  php              sleeping
// 66232  10116 0.0  9192K  php              sleeping
// 98592  98582 0.0  504K+  php              sleeping // 以下全是子进程
// 98591  98582 0.0  508K+  php              sleeping
// 98590  98582 0.0  504K+  php              sleeping
// 98589  98582 0.0  508K+  php              sleeping
// 98588  98582 0.0  504K+  php              sleeping
// 98587  98582 0.0  508K+  php              sleeping
// 98586  98582 0.0  504K+  php              sleeping
// 98585  98582 0.0  508K+  php              sleeping
// 98584  98582 0.0  504K+  php              sleeping
// 98583  98582 0.0  508K+  php              sleeping
// 98582  97030 0.0  7504K+ php              sleeping // 父进程
// 76423  1     2.9  3238M  phpstorm         sleeping
// 66232  10116 0.0  9192K  php              sleeping
// 66168  902   0.0  18M    php              sleeping
// 66228  86718 0.0  9532K  php              sleeping
// 66196  18300 0.0  9616K  php              sleeping
// 98592  98582 0.0  504K   php              sleeping
// 98591  98582 0.0  508K   php              sleeping
// 98590  98582 0.0  504K   php              sleeping
// 98589  98582 0.0  508K   php              sleeping
// 98588  98582 0.0  504K   php              sleeping
// 98587  98582 0.0  508K   php              sleeping
// 98586  98582 0.0  504K   php              sleeping
// 98585  98582 0.0  508K   php              sleeping
// 98584  98582 0.0  504K   php              sleeping
// 98583  98582 0.0  508K   php              sleeping
// 98582  97030 0.0  7504K  php              sleeping
// 76423  1     0.0  3238M  phpstorm         sleeping
// 66232  10116 0.0  9192K  php              sleeping
// 66196  18300 0.0  9616K  php              sleeping
// 66168  902   0.0  18M    php              sleeping
// 66228  86718 0.0  9532K  php              sleeping
// 76423  1     3.6  3238M  phpstorm         sleeping
// 66228  86718 0.0  9532K  php              sleeping
// 66196  18300 0.0  9616K  php              sleeping
// 66232  10116 0.0  9192K  php              sleeping
// 66168  902   0.0  18M    php              sleeping
// ^C
// ➜  php 


// sleep函数是否会真的导致进程挂起休眠，让出cpu执行权？
// 是的， sleep() 函数会让进程挂起休眠，直到指定的时间（秒数）过去后再继续执行。调用sleep()函数会将进程状态设置为 "S" (sleeping)，这表示进程在等待某些事件发生，例如时钟中断或信号。该过程指示此进程当前处于非运行状态，并且会导致 CPU 让出控制权在超时结束前不再分配给它。 换句话说，sleep()几乎完全消耗了CPU分配，因此CPU将移交给其他进程，在超时结束时，进程将从指定的睡眠时间恢复并继续执行。

// 如果将sleep函数换成复杂的代码逻辑，执行时间大约5s，那么某一个时刻同时并行执行的PHP进程有多少？
// 如果将sleep()函数替换为大约执行5秒钟的复杂代码逻辑，那么，在某个时间段内可能存在多达10个PHP进程并行执行的情况。实际上，仅仅存在10个子进程，所以在任何时候只有10个PHP进程正在执行处理。然而，如果一个子进程消耗的时间超过了5秒钟，下一个子进程会在已有的子进程还在执行的情况下立即启动。因此，某个时刻可能会有多达10个子进程同时处于活动状态。但是，由于PHP进程不是使用多线程模型实现的，因此操作系统不会在并发阅读不同时给予每个进程单独的CPU时间片。相反，每个进程将以轮询方式互斥地访问CPU，因此实际上每个进程都会分配一些CPU时间片，并在相应的迭代中分别分配 cpu 时钟周期。


// php exit函数会立即结束退出PHP进程？
// 是的，exit()函数会立即终止PHP进程，不会等待正在执行的代码或函数执行完成。当调用exit()时，流程会立即停止，已在进程流程中执行的代码也会立即终止。这意味着，如果在一个子进程中调用了exit()函数，那么子进程将立即退出，不会继续执行任何正在执行的代码块或函数。调用exit()代码后，进程将立即停止，不会等待其他子进程或父进程执行完毕。需要注意的是，调用exit()函数不会刷出缓冲区中的数据，因此在将进程标记为终止之前，您需要使用flush()函数强制把缓冲区的数据写入文件或输出。

